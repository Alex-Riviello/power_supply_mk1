C51 COMPILER V9.53.0.0   INTERRUPTS                                                        11/07/2017 22:12:19 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE INTERRUPTS
OBJECT MODULE PLACED IN .\src\Interrupts.OBJ
COMPILER INVOKED BY: c:\SiliconLabs\SimplicityStudio\v4\developer\toolchains\keil_8051\9.53\BIN\C51.exe C:\Users\Alex\Si
                    -mplicityStudio\v4_workspace\PowerSupply_Rev01\src\Interrupts.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) 
                    -FLOATFUZZY(3) OPTIMIZE(9,SPEED) DEFINE(NDEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\Alex\SimplicityStudio\v4_w
                    -orkspace\PowerSupply_Rev01\inc;C:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.0.5//Device/shared/si8051base;C
                    -:/SiliconLabs/SimplicityStudio/v4/developer/sdks/8051/v4.0.5//Device/EFM8BB1/inc) REGFILE(PowerSupply_Rev01.ORC) PRINT(.
                    -\src\Interrupts.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\Interrupts.OBJ)

line level    source

   1          //=========================================================
   2          // src/Interrupts.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!
   7          //=========================================================
   8          
   9                   
  10          // USER INCLUDES                        
  11          #include <SI_EFM8BB1_Register_Enums.h>
  12          #include "EFM8BB1_SMBus_SlaveMultibyteHWACK.h"
  13          
  14          //Device Address = 0x6B
  15          #define P_VOLTAGE_MSB 0x00
  16          #define P_VOLTAGE_LSB 0x01
  17          #define N_VOLTAGE_MSB 0x02
  18          #define N_VOLTAGE_LSB 0x03
  19          
  20          uint16_t CEX0_Compare_Value;       // Holds current PCA compare value
  21          uint16_t CEX1_Compare_Value;
  22          
  23          //-----------------------------------------------------------------------------
  24          // SMBUS0_ISR
  25          //-----------------------------------------------------------------------------
  26          //
  27          // SMBUS0 ISR Content goes here. Remember to clear flag bits:
  28          // SMB0CN0::SI (SMBus Interrupt Flag)
  29          //
  30          // SMBus ISR state machine
  31          // - Slave only implementation - no master states defined
  32          // - All incoming data is written to global variable <SMB_DATA_IN>
  33          // - All outgoing data is read from global variable <SMB_DATA_OUT>
  34          //
  35          //-----------------------------------------------------------------------------
  36          SI_INTERRUPT(SMBUS0_ISR, SMBUS0_IRQn)
  37          {
  38   1         static uint8_t sent_byte_counter;
  39   1         static uint8_t rec_byte_counter;
  40   1      
  41   1         if (SMB0CN0_ARBLOST == 0)
  42   1         {
  43   2            switch (SMB0CN0 & 0xF0)          // Decode the SMBus status vector
  44   2            {
  45   3               // Slave Receiver: Start+Address received
  46   3               case  SMB_SRADD:
  47   3      
  48   3                  SMB0CN0_STA = 0;           // Clear SMB0CN0_STA bit
  49   3      
  50   3                  sent_byte_counter = 1;     // Reinitialize the data counters
  51   3                  rec_byte_counter = 1;
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        11/07/2017 22:12:19 PAGE 2   

  52   3      
  53   3                  if ((SMB0DAT & 0x01) == READ) // If the transfer is a master READ,
  54   3                  {
  55   4                      if(SMB_DATA_IN[0] == P_VOLTAGE_MSB){
  56   5                              SMB0DAT = p_voltage_val_msb;
  57   5                              sent_byte_counter++;
  58   5                              SMB_DATA_IN[0] = SMB_DATA_IN[0]+1;
  59   5                      }
  60   4                      else if(SMB_DATA_IN[0] == P_VOLTAGE_LSB){
  61   5                              SMB0DAT = p_voltage_val_lsb;
  62   5                              sent_byte_counter++;
  63   5                              SMB_DATA_IN[0] = SMB_DATA_IN[0]+1;
  64   5                      }
  65   4                      else if(SMB_DATA_IN[0] == N_VOLTAGE_MSB){
  66   5                              SMB0DAT = n_voltage_val_msb;
  67   5                              sent_byte_counter++;
  68   5                              SMB_DATA_IN[0] = SMB_DATA_IN[0]+1;
  69   5                      }
  70   4                      else if(SMB_DATA_IN[0] == N_VOLTAGE_LSB){
  71   5                              SMB0DAT = n_voltage_val_lsb;
  72   5                              sent_byte_counter++;
  73   5                              SMB_DATA_IN[0] = SMB_DATA_IN[0]+1;
  74   5                      }
  75   4                      else{
  76   5                              SMB0DAT = 0xAA;
  77   5                              sent_byte_counter++;
  78   5                              SMB_DATA_IN[0] = SMB_DATA_IN[0]+1;
  79   5                      }
  80   4                  }
  81   3                  //else{
  82   3                  //  SMB0DAT = 0x6B;
  83   3                  //  sent_byte_counter++;
  84   3                  //
  85   3                  //}
  86   3                  break;
  87   3      
  88   3               // Slave Receiver: Data received
  89   3               case  SMB_SRDB:
  90   3      
  91   3                  if (rec_byte_counter < NUM_BYTES_WR) //If under 2, received device address
  92   3                  {                                    //Next byte has to be register address
  93   4                     // Store incoming data
  94   4                     SMB_DATA_IN[0] = SMB0DAT; //SMB_DATA_IN[0] stores register address
  95   4                     rec_byte_counter++;
  96   4      
  97   4                    // SMB0CN0_ACK = 1;        // SMB0CN0_ACK received data
  98   4                  }
  99   3                  else if(SMB_DATA_IN[0] == P_VOLTAGE_MSB){
 100   4                      p_voltage_val_msb = SMB0DAT;
 101   4                      rec_byte_counter++;
 102   4                      SMB_DATA_IN[0] = SMB_DATA_IN[0] + 1;
 103   4                  }
 104   3                  else if(SMB_DATA_IN[0] == P_VOLTAGE_LSB){
 105   4                      p_voltage_val_lsb = SMB0DAT;
 106   4                      rec_byte_counter++;
 107   4                      SMB_DATA_IN[0] = SMB_DATA_IN[0] + 1;
 108   4                  }
 109   3                  else if(SMB_DATA_IN[0] == N_VOLTAGE_MSB){
 110   4                      n_voltage_val_msb = SMB0DAT;
 111   4                      rec_byte_counter++;
 112   4                      SMB_DATA_IN[0] = SMB_DATA_IN[0] + 1;
 113   4                  }
 114   3                  else if(SMB_DATA_IN[0] == N_VOLTAGE_LSB){
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        11/07/2017 22:12:19 PAGE 3   

 115   4                      n_voltage_val_lsb = SMB0DAT;
 116   4                      rec_byte_counter++;
 117   4                      SMB_DATA_IN[0] = SMB_DATA_IN[0] + 1;
 118   4                  }
 119   3                  else{
 120   4                      SMB_DATA_IN[1] = SMB0DAT; //Store data somewhere (might not use it)
 121   4                      rec_byte_counter++;
 122   4                  }
 123   3                /*  {
 124   3                     // Store incoming data
 125   3                     SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT;
 126   3      
 127   3                     DATA_READY = 1;         // Indicate new data fully received
 128   3                  }*/
 129   3                  SMB0CN0_ACK = 1; //This necessary?
 130   3                  break;
 131   3      
 132   3               // Slave Receiver: Stop received while either a Slave Receiver or
 133   3               // Slave Transmitter
 134   3               case  SMB_SRSTO:
 135   3      
 136   3                  SMB0CN0_STO = 0;           // SMB0CN0_STO must be cleared by software when
 137   3                                             // a STOP is detected as a slave
 138   3                  break;
 139   3      
 140   3               // Slave Transmitter: Data byte transmitted
 141   3               case  SMB_STDB:
 142   3      
 143   3                  if (SMB0CN0_ACK == 1)      // If Master SMB0CN0_ACK's, send the next byte
 144   3                  {
 145   4                      if(SMB_DATA_IN[0] == P_VOLTAGE_MSB){
 146   5                              SMB0DAT = p_voltage_val_msb;
 147   5                              sent_byte_counter++;
 148   5                              SMB_DATA_IN[0] = SMB_DATA_IN[0]+1;
 149   5                      }
 150   4                      else if(SMB_DATA_IN[0] == P_VOLTAGE_LSB){
 151   5                              SMB0DAT = p_voltage_val_lsb;
 152   5                              sent_byte_counter++;
 153   5                              SMB_DATA_IN[0] = SMB_DATA_IN[0]+1;
 154   5                      }
 155   4                      else if(SMB_DATA_IN[0] == N_VOLTAGE_MSB){
 156   5                              SMB0DAT = n_voltage_val_msb;
 157   5                              sent_byte_counter++;
 158   5                              SMB_DATA_IN[0] = SMB_DATA_IN[0]+1;
 159   5                      }
 160   4                      else if(SMB_DATA_IN[0] == N_VOLTAGE_LSB){
 161   5                              SMB0DAT = n_voltage_val_lsb;
 162   5                              sent_byte_counter++;
 163   5                              SMB_DATA_IN[0] = SMB_DATA_IN[0]+1;
 164   5                      }
 165   4                      else{
 166   5                              SMB0DAT = 0xAA;
 167   5                              sent_byte_counter++;
 168   5                              SMB_DATA_IN[0] = SMB_DATA_IN[0]+1;
 169   5                      }
 170   4                      /*
 171   4                     if (sent_byte_counter <= NUM_BYTES_RD)
 172   4                     {
 173   4                        // Prepare next outgoing byte
 174   4                        SMB0DAT = 0x6B;
 175   4                        sent_byte_counter++;
 176   4                     }*/
 177   4                  }                          // Otherwise, do nothing
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        11/07/2017 22:12:19 PAGE 4   

 178   3                  break;
 179   3      
 180   3               // Slave Transmitter: Arbitration lost, Stop detected
 181   3               //
 182   3               // This state will only be entered on a bus error condition.
 183   3               // In normal operation, the slave is no longer sending data or has
 184   3               // data pending when a STOP is received from the master, so the SMB0CN0_TXMODE
 185   3               // bit is cleared and the slave goes to the SRSTO state.
 186   3               case  SMB_STSTO:
 187   3      
 188   3                  SMB0CN0_STO = 0;           // SMB0CN0_STO must be cleared by software when
 189   3                                             // a STOP is detected as a slave
 190   3                  break;
 191   3      
 192   3               // Default: all other cases undefined
 193   3               default:
 194   3      
 195   3                  SMB0CF &= ~0x80;           // Reset communication
 196   3                  SMB0CF |= 0x80;
 197   3                  SMB0CN0_STA = 0;
 198   3                  SMB0CN0_STO = 0;
 199   3                  SMB0CN0_ACK = 1;
 200   3                  break;
 201   3            }
 202   2         }
 203   1         // SMB0CN0_ARBLOST = 1, Abort failed transfer
 204   1         else
 205   1         {
 206   2            SMB0CN0_STA = 0;
 207   2            SMB0CN0_STO = 0;
 208   2            SMB0CN0_ACK = 1;
 209   2         }
 210   1      
 211   1         SMB0CN0_SI = 0;                     // Clear SMBus interrupt flag
 212   1      }
 213          
 214          
 215          //-----------------------------------------------------------------------------
 216          // TIMER3_ISR
 217          //-----------------------------------------------------------------------------
 218          //
 219          // TIMER3 ISR Content goes here. Remember to clear flag bits:
 220          // TMR3CN::TF3H (Timer # High Byte Overflow Flag)
 221          // TMR3CN::TF3L (Timer # Low Byte Overflow Flag)
 222          //
 223          // A Timer3 interrupt indicates an SMBus SCL low timeout.
 224          // The SMBus is disabled and re-enabled here
 225          //
 226          //-----------------------------------------------------------------------------
 227          SI_INTERRUPT(TIMER3_ISR, TIMER3_IRQn)
 228          {
 229   1         SMB0CF  &= ~0x80;                   // Disable SMBus
 230   1         SMB0CF  |=  0x80;                   // Re-enable SMBus
 231   1         TMR3CN0 &= ~0x80;                   // Clear Timer3 interrupt-pending flag
 232   1      }
 233          
 234          //-----------------------------------------------------------------------------
 235          // PCA0_ISR
 236          //-----------------------------------------------------------------------------
 237          //
 238          // PCA0 ISR Content goes here. Remember to clear flag bits:
 239          // PCA0CN::CCF0 (PCA Module 0 Capture/Compare Flag)
 240          // PCA0CN::CCF1 (PCA Module 1 Capture/Compare Flag)
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        11/07/2017 22:12:19 PAGE 5   

 241          // PCA0CN::CCF2 (PCA Module 2 Capture/Compare Flag)
 242          // PCA0CN::CF (PCA Counter/Timer Overflow Flag)
 243          // PCA0PWM::COVF (Cycle Overflow Flag)
 244          //
 245          // This is the ISR for the PCA.  It handles the case when a match occurs on
 246          // channel 0, and updates the PCA0CPn compare register with the value held in
 247          // the global variable "CEX0_Compare_Value".
 248          //
 249          //-----------------------------------------------------------------------------
 250          SI_INTERRUPT (PCA0_ISR, PCA0_IRQn)
 251          {
 252   1         PCA0PWM &= ~0x20;                   // Clear cycle overflow flag
 253   1      
 254   1         PCA0PWM |= 0x80;                    // Target Auto-reload registers
 255   1      
 256   1         PCA0CPL0 = (CEX0_Compare_Value & 0x00FF);
 257   1         PCA0CPH0 = (CEX0_Compare_Value & 0xFF00)>>8;
 258   1      
 259   1         PCA0CPL1 = (CEX1_Compare_Value & 0x00FF);
 260   1         PCA0CPH1 = (CEX1_Compare_Value & 0xFF00)>>8;
 261   1      
 262   1         PCA0PWM &= ~0x80;                   // Target PCA0CPH/L registers
 263   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    290    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
